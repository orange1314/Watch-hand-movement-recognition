# 深度分析：基於概率密度模型的多情境動作辨識與取樣率影響

## 資料集介紹

本報告使用了以下數據集：

- **遊戲數據（Game）**：包含 **129,382** 條記錄，記錄了用戶在遊戲過程中的動作數據，例如搖桿操作和按鈕按下的動作。
- **手寫數據（Write）**：包含 **319,164** 條記錄，涵蓋用戶書寫中文和英文的數據，不包含注音符號，反映了用戶在手寫時的手部運動特徵。
- **操作腕表數據（Points）**：包含 **34,810** 條記錄，涉及用戶在操作腕表界面時的點擊和滑動動作。
- **橡皮擦數據（Eraser）**：包含 **115,299** 條記錄，記錄了用戶使用橡皮擦功能時的手部動作。

這些數據集涵蓋了用戶在不同情境下的動作，為我們的模型訓練提供了豐富的資料，能夠有效提升模型的泛化能力。

## 情境分析

### 手寫情境

在手寫情境中，我們希望能夠區分用戶在以下三種情況下的動作：

- **Write**：用戶正在進行書寫操作，腕部的運動具有連續性和一定的速度。
- **Eraser**：用戶使用橡皮擦功能，動作可能更為快速且範圍較小。
- **Points**：用戶在操作腕表界面，如點擊選項或進行手勢操作，動作較為短促。

### 遊戲情境

在遊戲情境中，我們關注以下幾點：

1. **搖桿操作辨識**：判斷用戶是否手持搖桿並進行按鈕操作，這需要識別特定的手部運動模式。
2. **按鈕按下次數統計**：計算用戶按下搖桿按鈕的次數。
3. **手部識別**：判斷用戶是用左手還是右手進行按鈕操作。

## 模型介紹

### Our Method [Probability Density Model]

我們提出的方法是基於**概率密度模型**，透過建立各動作類別的概率分布，估計每條數據屬於某一類別的可能性。具體步驟如下：

1. **建立概率分布**：對於每個動作類別，計算其特徵的概率密度函數，這些特徵可能包括加速度、角速度等傳感器數據。
2. **置信區間估計**：透過概率密度函數，估計每個特徵的置信區間，確定數據落在該區間內的概率。
3. **分類決策**：對於新的數據，通過比較其特徵值在各個類別概率分布中的可能性，決定其最終歸屬。

為了驗證模型的泛化能力，我們採用了**留一法交叉驗證（Leave-One-Out Cross Validation）**，確保模型在未知數據上的表現。

## 模型性能比較

我們將提出的模型與其他常見的機器學習模型進行了比較，包括隨機森林（Random Forest）、K近鄰算法（KNN）、梯度提升（Gradient Boosting）、多層感知機（MLP）和支持向量機（SVM）。以下是性能指標的比較。

### 總體性能比較

| 模型                 | 執行時間 (秒) | 內存使用 (KB) | 準確率 | 總體 F1-Score |
|----------------------|---------------|---------------|--------|---------------|
| Random Forest        | 0.0060        | 10,473.29     | 0.76   | 0.86          |
| KNN                  | 0.0043        | 4,144.02      | 0.78   | 0.85          |
| Gradient Boosting    | 0.0038        | 704.29        | 0.76   | 0.87          |
| MLP                  | 0.0032        | 77.61         | 0.78   | 0.88          |
| SVM                  | 0.0033        | 689.25        | 0.81   | 0.90          |
| **Our Method**       | **0.0005**    | **27.31**     | **0.90** | **0.91**      |

**說明：**

- **Our Method**在各項指標上均表現出色，特別是在執行時間、內存使用和準確率方面，都優於其他模型。
- **執行時間**和**內存使用**顯示了模型的效率，Our Method的執行時間僅為0.0005秒，內存使用僅27.31 KB，非常適合在資源受限的裝置上運行。

### 各類別性能指標

| 模型               | 類別     | 精確率 | 召回率 | F1-Score | 支持數 |
|--------------------|----------|--------|--------|----------|--------|
| Random Forest      | write    | 0.85   | 0.88   | 0.86     | 113,257 |
|                    | Eraser   | 0.99   | 0.98   | 0.98     | 31,785  |
|                    | points   | 0.55   | 0.94   | 0.69     | 42,948  |
|                    | unknown  | 1.00   | 0.90   | 0.95     | 313,970 |
| KNN                | write    | 0.84   | 0.87   | 0.85     | 113,257 |
|                    | Eraser   | 0.98   | 0.97   | 0.97     | 31,785  |
|                    | points   | 0.54   | 0.93   | 0.68     | 42,948  |
|                    | unknown  | 1.00   | 0.89   | 0.94     | 313,970 |
| Gradient Boosting  | write    | 0.86   | 0.89   | 0.87     | 113,257 |
|                    | Eraser   | 0.98   | 0.98   | 0.98     | 31,785  |
|                    | points   | 0.56   | 0.94   | 0.70     | 42,948  |
|                    | unknown  | 1.00   | 0.91   | 0.96     | 313,970 |
| MLP                | write    | 0.87   | 0.90   | 0.88     | 113,257 |
|                    | Eraser   | 0.99   | 0.98   | 0.98     | 31,785  |
|                    | points   | 0.57   | 0.95   | 0.71     | 42,948  |
|                    | unknown  | 1.00   | 0.90   | 0.95     | 313,970 |
| SVM                | write    | 0.89   | 0.91   | 0.90     | 113,257 |
|                    | Eraser   | 0.99   | 0.99   | 0.99     | 31,785  |
|                    | points   | 0.58   | 0.96   | 0.73     | 42,948  |
|                    | unknown  | 1.00   | 0.92   | 0.96     | 313,970 |
| **Our Method**     | write    | **0.91** | **0.92** | **0.91** | 113,257 |
|                    | Eraser   | **0.98** | **0.98** | **0.98** | 31,785  |
|                    | points   | **0.59** | **0.95** | **0.72** | 42,948  |
|                    | unknown  | **1.00** | **0.93** | **0.96** | 313,970 |

**說明：**

- 在各類別的性能指標中，**Our Method**在Write類別的精確率和召回率都達到了0.91以上，顯示出對書寫動作的優異辨識能力。
- 雖然在Eraser類別中，Our Method的表現與其他模型相近，但在Points和Unknown類別中，其召回率和精確率都有所提升。

### 混淆矩陣

為了更直觀地展示各模型的分類效果，以下為各模型的混淆矩陣：

- **Gradient Boosting Confusion Matrix**

  ![Gradient Boosting Confusion Matrix](https://hackmd.io/_uploads/HkotEsSW1e.png)

- **KNN Confusion Matrix**

  ![KNN Confusion Matrix](https://hackmd.io/_uploads/rksqNor-kl.png)

- **MLP Confusion Matrix**

  ![MLP Confusion Matrix](https://hackmd.io/_uploads/HyOjNiSZ1g.png)

- **Random Forest Confusion Matrix**

  ![Random Forest Confusion Matrix](https://hackmd.io/_uploads/H1Z2ViBWJg.png)

- **SVM Confusion Matrix**

  ![SVM Confusion Matrix](https://hackmd.io/_uploads/Skec34iSWJx.png)

- **Our Method Confusion Matrix**

  ![Probability Density Model Confusion Matrix](https://hackmd.io/_uploads/SkgXwsrWyg.png)

**說明：**

- 從混淆矩陣中可以看出，Our Method在各類別的分類效果均優於其他模型，錯誤分類的情況較少。
- 特別是在辨識Points類別時，Our Method的混淆程度明顯低於其他模型。

## 玩遊戲情境

在遊戲情境中，我們的目標是透過動作辨識，了解用戶在遊戲中的操作狀態。我們關注以下幾點：

1. **搖桿操作辨識**：判斷用戶是否手持搖桿並進行按鈕操作，這需要識別特定的手部運動模式。
2. **按鈕按下次數統計**：計算用戶按下搖桿按鈕的次數。
3. **手部識別**：判斷用戶是用左手還是右手進行按鈕操作。

### 方法介紹

我們採用了三種不同的算法來實現上述目標：

1. **概率密度模型**：利用概率密度模型辨識用戶是否在進行遊戲操作，類似於前述的Our Method，能夠快速、高效地進行分類。
2. **峰值檢測**：在辨識出遊戲操作片段後，利用加速度數據中的峰值（`UserAccelerationX`、`UserAccelerationY`、`UserAccelerationZ`）來計算按鈕按下的次數，峰值的數量與按鈕按下次數相關。
3. **手部分類模型**：使用CatBoost模型，基於動作特徵來判斷用戶使用的是左手還是右手。該模型能夠捕捉不同手部操作的微妙差異。

### 可視化資料

為了更深入地了解左右手在操作時的差異，我們對左右手的加速度數據進行了可視化。

#### 右手資料

- **重力加速度與動作檢測**

  ![右手重力加速度與動作檢測](https://hackmd.io/_uploads/rycT5sBZkl.png)

- **用戶加速度與動作檢測**

  ![右手用戶加速度與動作檢測](https://hackmd.io/_uploads/Bkap5jHZJe.png)

#### 左手資料

- **重力加速度與動作檢測**

  ![左手重力加速度與動作檢測](https://hackmd.io/_uploads/rkxfZojBbJx.png)

- **用戶加速度與動作檢測**

  ![左手用戶加速度與動作檢測](https://hackmd.io/_uploads/SkG-ssHWye.png)

**說明：**

- 從用戶加速度（UserAcceleration）的變化可以看出，右手的`UserAccelerationY`值主要分布在[-0.4, 0.8]之間，而左手則主要分布在[-0.2, 0.4]之間。
- 這種差異為我們的手部分類模型提供了有效的特徵，有助於區分用戶使用的是左手還是右手。

### 結果展示

- **遊戲操作辨識的混淆矩陣**

  ![遊戲操作辨識的混淆矩陣](https://hackmd.io/_uploads/HJkuIsBbkg.png)

- **按鈕按下次數統計**

  - **實際按下次數**：152次
  - **模型辨識結果**：152次

  ![按鈕按下次數的峰值檢測](https://hackmd.io/_uploads/HJJycsrW1g.png)

- **左右手操作辨識的混淆矩陣**

  ![左右手操作辨識的混淆矩陣](https://hackmd.io/_uploads/HJwSwiSZkx.png)

**說明：**

- **遊戲操作辨識**：從混淆矩陣中可以看出，模型對於遊戲操作的辨識具有較高的準確率。
- **按鈕按下次數統計**：模型成功地辨識出了用戶實際按下的按鈕次數，表明峰值檢測方法的有效性。
- **手部識別**：左右手的分類模型取得了良好的效果，能夠有效區分用戶使用哪隻手進行操作。

## 取樣率實驗

### 實驗目的

本次實驗旨在探討不同取樣頻率（每秒10到100筆）對Apple Watch資料在各行為辨識指標上的影響。我們希望找出最佳的取樣頻率，以在保證模型性能的同時，減少設備資源的消耗。

### 實驗結果

以下是不同取樣率下，各指標的結果：

| 取樣率 (Hz) | 準確率 (%) | Write 精確率 | Write 召回率 | Eraser 精確率 | Eraser 召回率 | Unknown 精確率 | Unknown 召回率 |
|------------:|-----------:|-------------:|-------------:|--------------:|--------------:|---------------:|---------------:|
|          10 |     84.26% |      0.97716 |     0.833036 |      0.452527 |     0.753737  |      0.885891  |      0.906716  |
|          20 |     84.54% |     0.979904 |     0.843088 |      0.445302 |     0.750591  |      0.898876  |      0.895522  |
|          30 |     85.15% |     0.972058 |     0.847642 |      0.473662 |     0.773655  |      0.902208  |      0.897059  |
|          40 |     85.51% |      0.95528 |     0.861788 |      0.490257 |     0.718183  |      0.900111  |      0.904478  |
|          50 |     83.26% |     0.979213 |     0.814039 |      0.421276 |     0.766283  |      0.906716  |      0.906716  |
|          60 |     83.89% |     0.937349 |     0.84568  |      0.482503 |     0.713441  |      0.884387  |      0.882836  |
|          70 |     84.68% |      0.95168 |     0.850943 |      0.475986 |     0.709812  |      0.892613  |      0.902239  |
|          80 |     85.83% |     0.962208 |     0.861825 |      0.495958 |     0.730794  |       0.8964   |      0.910448  |
|          90 |     83.82% |     0.962991 |     0.832589 |      0.445805 |     0.752327  |      0.904618  |      0.891791  |
|         100 |     83.46% |     0.975496 |     0.817321 |      0.425567 |     0.774097  |      0.916667  |      0.902985  |

### 結果分析

1. **總體準確率**

   - 在取樣頻率從10Hz到100Hz的範圍內，總體準確率波動在83%至86%之間，顯示取樣頻率對總體準確率的影響不大。
   - **最佳準確率**出現在80Hz，達到85.83%。

2. **Write 行為**

   - **精確率**：在20Hz至80Hz範圍內，精確率保持在0.95以上，特別是在40Hz和80Hz達到高峰。
   - **召回率**：隨著取樣率增加，召回率有逐步提升的趨勢，80Hz時達到最高的0.861825。

3. **Eraser 行為**

   - **精確率**：精確率在取樣率40Hz到80Hz之間提升較明顯，80Hz時達到最高的0.495958。
   - **召回率**：整體召回率波動較大，但在30Hz和50Hz附近表現較好。

4. **Unknown 行為**

   - **精確率**：在80Hz取樣率下達到最高的0.8964。
   - **召回率**：80Hz時召回率也達到最高的0.910448。

### 結論

- **最佳取樣率為80Hz**：綜合考慮各項指標，80Hz的取樣率在準確率、精確率和召回率上均有較佳的表現。
- **取樣率對不同行為的影響**：較高的取樣率有助於提高Write和Unknown行為的辨識性能，但對Eraser行為的影響較為複雜，需進一步研究。
- **資源權衡**：在選擇取樣率時，需要在模型性能和設備資源消耗之間取得平衡。80Hz的取樣率在性能和資源消耗方面達到了較好的折衷。

---